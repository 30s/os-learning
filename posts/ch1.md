Linux内核学习之一-Take It Easy！
======

## 起-做个了解底层的码农

节前上班的日子总是那么悠闲，这么集中的时间，正好集中学习一下。一直以来都做的是Java开发，对不了解底层，总觉得心有不安。听到别人说起“进程切换”、“内存管理”、“内核态和用户态”，也总是觉得似懂非懂。所以就干脆把目标定大一点，学学Linux内核吧！

## 承-下载Linux内核及编译

### 下载

其实如果你使用Linux系统，那么内核的源码就直接在/usr/src目录下了。不过还是建议去下载一份最新的源码！哪里下载呢？Linux的作者-大名鼎鼎的Linus Torvalds也是Git的作者，所以你知道最新的源码去哪里下载了吧！赶紧去[https://github.com/torvalds/linux](https://github.com/torvalds/linux)拉一份最新代码吧！

	git clone https://github.com/torvalds/linux
	
代码一共有1.4G，所以耐心等待一会吧…
	
### 编译内核

编译内核是个苦力活。首先，你必须得在Linux系统下，因为编译Linux是依赖gcc的。然后，你编译的版本得跟当前版本一致（博主不完全肯定，但是实践下来是这样）。

然后就是编译了！Linux内核编译反而会简单，因为它没有太多的依赖要编译。所以可以用常用的三段式（需要root权限）：

	make config
	make
	make install #install就替换当前内核了，三思而后行！
	
1. `make config`是交互式的，会需要指定使用什么不使用什么。不过这选项实在太多了点，第一次大概选了几百个选项吧…后面才知道，可以图个方便，用`make deconfig`来替代了。反正我们只是看看能不能编译嘛，嗯。
2. `make`是个很漫长的过程。
3. `make install`会替换当前内核了，我们这边就不替换了。

总之到了这里，已经有一些成就感了！

### 开始读代码？

关于Linux的代码结构有很多文章，例如这篇：[http://blog.csdn.net/liaoshengjiong/article/details/3957654](http://blog.csdn.net/liaoshengjiong/article/details/3957654)，就不赘述了。查看一下代码，乖乖，一共500多万行，估计一两年也读不完吧！我的目的只是了解底层的基本原理，没有必要深入到各种细节。更何况，好多驱动、文件、内存的概念也不熟悉，怎么办呢？还是先看书吧！

## 转-还是读书吧

我之前的观点是读源码前至少了解项目的领域知识。对于Java码农来说，操作系统毕竟不是熟悉的领域，一开始就看源码不太现实。一两本参考书是必不可少的。这里我也浏览过几本书，最后觉得比较好的是《Linux内核设计与实现》，这本书大部分是理论为主，但是最后总会介绍到大致对应的代码在哪里，就起到非常好的提纲挈领的效果。对于有过一些代码经验的人来说，会觉得异常亲切。关键是，**它只有200页！**

浏览的另外几本书，包括大名鼎鼎的《深入理解计算机系统》，这本书全面详尽，但是更适合做教材，实践性弱了点（虽然它也有很多例子）。还有一本《深入理解LINUX内核》，内容对于入门又深了一点。一句话，讲了“深入”的都不太适合入门！还有本《30天自制操作系统》，不是说书不好，而是太基础了点，看到“用二进制编辑器写代码”就看不下去了。

## 合-Take It Easy!

好了，下面开始学习了。其实弄了那么多，我想说一件事就是，内核虽然很难，很多人只靠研究它就已经成了大牛。但是它难在于，越是底层的东西，对质量、稳定性、性能要求越高，同时需要考虑的情况越多，但是其实其理论和思想，可能大家都是耳熟能详的。

例如，在“进程管理”部分，我们常见的“进程描述符”对应的是`sched.h`中的一个结构：`task_struct`:

```c
struct task_struct {
	volatile long state;	/* -1 unrunnable, 0 runnable, >0 stopped */
	struct thread_info *thread_info;
	atomic_t usage;
	unsigned long flags;	/* per process flags, defined below */
	unsigned long ptrace;
	…
}
```

而进程是保存在一个带优先级的双向链表里的，这跟Java里的PriorityQueue原理相似。怎么样，是不是觉得“进程调度”也没有那么神秘了呢？

同理，我们经常说“内核态”和“用户态”，实际上两者的代码都是c实现，搞出一个“内核态”是为了安全和某些性能的考虑，但是区别也没有想象中的那么大！其实这跟我们熟悉的“平台”和“业务逻辑”是不是有那么点相似呢？

总之，掌握基本的内核知识，应该还是不难的！好处就是，以后对程序设计的理解会更进一步了！

PS:博主对c和Linux的理解都是入门水平都算不上，如果有问题欢迎指正，我会很开心接受的！